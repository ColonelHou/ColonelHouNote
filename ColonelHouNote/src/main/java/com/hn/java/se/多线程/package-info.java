/**
 * 
 */
/**
 * @author Colonel.Hou
 * 
 * 
 * 
 * 锁机制：Object就像大房子， 里边有很多上锁小房子（synchronized）， 
 *       房门口放一把钥匙（可以打开所有上锁的房子）， 想进房子中某小房间的人称为线程，
 *       每次使用完钥匙都会放回去，即使连续使用二个小房间也要把钥匙放回去，随用随借，用完即还。
 *       多人等待钥匙时， 谁会先抢到钥匙呢？不一定， 决定权在JVM。
 *   同步代码块与同步方法区别：
 *       1.尺寸上讲， 同步方法比较大，可以想像成同步代码块是没有上锁的房间的一块屏风隔开的空间。
 *       2.同步代码块还可以人为指定获得某个其它对像的钥匙（指定哪把钥匙才能打开此屏风， 这样的话，你需要
 *         到另一房子那儿把那把钥匙取到并用此打开屏风）
 *   为什么使用同步代码块呢？
 *       首先同步很影响效率， 同步的代码越多对效率影响越严重。
 *       另外同步代码块可以指定可以指定这把钥匙。
 *   sleep与同步？
 *       进行同步中调用了sleep方法后，线程就停止到那儿了， 即使在睡觉的时候也拿着这把钥匙。
 *   为什么不是一把钥匙一个门呢？
 *       钥匙的产生保管、获得、归还等，可能随同步方法增加复杂性几何级增加，
 *   synchronized二种作用域：
 *       1.某个对象实例内， 就是同步方法防止多线程同时访问这个对象的同步方法。
 *         对象级别的，多线程访问此类不同实例的同步方法是不影响的。
 *       2.类范围的， 防止多线程同步访问这个类的static方法， 他可以对类的所有实例起作用。
 *       3.方法中块同步
 *   Synchronized关键字是不能继承的
 *   
 *   注意：
 *       1.无论synchronized关键字加到方法上还是对象上，它取得的锁都是对象， 而不是把代码或者函数当作锁。
 *       2.每个对象只有一个锁与之关联。
 *       3.实现同步需要系统很大的开销为代价的， 甚至可能造成死锁， 所以尽量避免无谓的同步控制。
 *       
 *   同步方法， 此时synchronized锁定的是哪个对象呢？
 *       它锁定的是调用这个同步方法的对象， 也就是说， 当一个对象P在不同的线程中执行这个同步方法时会形成互斥。
 *       对象锁， 访问同步方法前先获得此对象的锁。
 *   类锁：
 *       P1.class或者同步静态方法。
 *       需要搞清楚锁的是那个对象
 *       
 *   共享资源的同步访问更加安全：
 *       1.定义private的instance变量加get/set方法， 不要定义protected/public， 否则外界可以绕过同步方法
 *         的控制直接取得它。
 *
 */
package com.hn.java.se.多线程;